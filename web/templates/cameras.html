{% extends 'base.html' %}

{% block header %}
  <h1>{% block title %}Robot & Camera Monitoring{% endblock %}</h1>
{% endblock %}

<style>
  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateX(-20px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  .animate-fadeInUp {
    animation: fadeInUp 0.6s ease-out forwards;
  }
  .animate-slideIn {
    animation: slideIn 0.4s ease-out forwards;
  }
  .animation-delay-2000 {
    animation-delay: 2s;
  }
  .animation-delay-4000 {
    animation-delay: 4s;
  }
  .draggable-panel {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  .draggable-panel:hover {
    transform: translateY(-2px);
  }
  .glassmorphism {
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
  }
  .camera-feed-container {
    background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.2);
  }
</style>

{% block content %}
  <noscript>
    <div class="bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-600 text-red-700 dark:text-red-200 px-4 py-3 rounded mb-4">
      <p><strong>Warning:</strong> JavaScript is disabled in your browser. This website will not function correctly without JavaScript enabled.</p>
      <p>Please use a browser with JavaScript enabled for the best experience.</p>
    </div>
  </noscript>

  <!-- Main Dashboard Layout -->
  <div class="grid grid-cols-2 grid-rows-2 h-screen gap-6 p-6 bg-gradient-to-br from-slate-100 via-blue-50 to-indigo-100 dark:from-gray-900 dark:via-blue-900/20 dark:to-indigo-900/20">
    <!-- Animated background pattern -->
    <div class="fixed inset-0 opacity-30 dark:opacity-10 pointer-events-none">
      <div class="absolute top-1/4 left-1/4 w-96 h-96 bg-gradient-to-r from-blue-300 to-purple-300 rounded-full mix-blend-multiply filter blur-xl animate-pulse"></div>
      <div class="absolute top-3/4 right-1/4 w-96 h-96 bg-gradient-to-r from-green-300 to-teal-300 rounded-full mix-blend-multiply filter blur-xl animate-pulse animation-delay-2000"></div>
      <div class="absolute bottom-1/4 left-1/3 w-96 h-96 bg-gradient-to-r from-pink-300 to-orange-300 rounded-full mix-blend-multiply filter blur-xl animate-pulse animation-delay-4000"></div>
    </div>
    <!-- Left Camera Feed -->
    <div class="bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-xl hover:shadow-2xl transition-all duration-300 draggable-panel overflow-hidden animate-fadeInUp" draggable="true" style="animation-delay: 0.1s">
      <div class="bg-gradient-to-r from-blue-600 via-purple-600 to-indigo-600 dark:from-blue-700 dark:via-purple-700 dark:to-indigo-700 p-4 flex items-center justify-between relative">
        <div class="absolute inset-0 bg-gradient-to-r from-blue-400/20 to-purple-400/20 blur-xl"></div>
        <h3 class="text-white font-bold flex items-center relative z-10">
          <div class="bg-white/20 p-2 rounded-lg mr-3 backdrop-blur-sm">
            <span class="material-icons text-white">videocam</span>
          </div>
          <span class="editable-text cursor-pointer hover:bg-white/20 px-3 py-2 rounded-lg transition-colors duration-200 backdrop-blur-sm" onclick="editText(this, event)" data-camera-id="left">Left Camera</span>
        </h3>
        <div class="flex items-center gap-3 relative z-10">
          <select class="bg-white/20 backdrop-blur-sm text-white text-sm rounded-lg px-3 py-2 border border-white/30 outline-none hover:bg-white/30 transition-colors duration-200" id="leftCameraSelect" onchange="switchCamera('left', this.value)">
            <option value="1" class="bg-gray-800 text-white">📹 Camera 1</option>
            <option value="2" class="bg-gray-800 text-white">📹 Camera 2</option>
            <option value="3" class="bg-gray-800 text-white">📹 Camera 3</option>
            <option value="4" class="bg-gray-800 text-white">📹 Camera 4</option>
          </select>
          <button onclick="toggleCamera('left')" class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 border border-white/30 hover:scale-105" id="leftCameraToggle">
            <span class="material-icons text-sm mr-1">play_arrow</span>
            Start
          </button>
          <button onclick="testCameraConnectivity()" class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 px-3 py-2 rounded-lg text-sm transition-all duration-200 border border-white/30" title="Test Connection">
            <span class="material-icons text-sm">wifi_find</span>
          </button>
          <button class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 p-2 rounded-lg drag-handle transition-all duration-200 border border-white/30">
            <span class="material-icons">drag_indicator</span>
          </button>
        </div>
      </div>
      <div class="h-full bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-900 flex items-center justify-center relative overflow-hidden">
        <div class="absolute inset-0 bg-gradient-to-br from-blue-500/5 to-purple-500/5"></div>
        <div id="leftCameraPlaceholder" class="text-center text-gray-500 dark:text-gray-400 relative z-10 transform transition-all duration-500">
          <div class="bg-gray-200 dark:bg-gray-700 rounded-full p-8 mx-auto mb-4 w-24 h-24 flex items-center justify-center shadow-lg">
            <span class="material-icons text-5xl text-gray-400 dark:text-gray-500 animate-pulse">videocam_off</span>
          </div>
          <p class="text-lg font-medium">Camera Offline</p>
          <p class="text-sm opacity-75 mt-1">Click Start to begin streaming</p>
          <div class="mt-4 text-xs opacity-60">
            <p>💡 Tips:</p>
            <p>• Use test button to check connectivity</p>
            <p>• Press Ctrl+1 to toggle this camera</p>
            <p>• Press Ctrl+D for demo mode</p>
          </div>
        </div>
        <img id="leftCameraFeed" class="w-full h-full object-contain hidden rounded-lg shadow-inner" alt="Left Camera Feed" />
        <div id="leftCameraOverlay" class="absolute top-4 left-4 bg-black/70 backdrop-blur-sm text-white px-3 py-2 rounded-lg text-sm font-medium hidden">
          <span class="inline-block w-2 h-2 bg-red-500 rounded-full mr-2 animate-pulse"></span>
          LIVE
        </div>
      </div>
    </div>

    <!-- Right Camera Feed -->
    <div class="bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-xl hover:shadow-2xl transition-all duration-300 draggable-panel overflow-hidden animate-fadeInUp" draggable="true" style="animation-delay: 0.2s">
      <div class="bg-gradient-to-r from-green-600 via-teal-600 to-emerald-600 dark:from-green-700 dark:via-teal-700 dark:to-emerald-700 p-4 flex items-center justify-between relative">
        <div class="absolute inset-0 bg-gradient-to-r from-green-400/20 to-teal-400/20 blur-xl"></div>
        <h3 class="text-white font-bold flex items-center relative z-10">
          <div class="bg-white/20 p-2 rounded-lg mr-3 backdrop-blur-sm">
            <span class="material-icons text-white">videocam</span>
          </div>
          <span class="editable-text cursor-pointer hover:bg-white/20 px-3 py-2 rounded-lg transition-colors duration-200 backdrop-blur-sm" onclick="editText(this, event)" data-camera-id="right">Right Camera</span>
        </h3>
        <div class="flex items-center gap-3 relative z-10">
          <select class="bg-white/20 backdrop-blur-sm text-white text-sm rounded-lg px-3 py-2 border border-white/30 outline-none hover:bg-white/30 transition-colors duration-200" id="rightCameraSelect" onchange="switchCamera('right', this.value)">
            <option value="2" class="bg-gray-800 text-white">📹 Camera 2</option>
            <option value="1" class="bg-gray-800 text-white">📹 Camera 1</option>
            <option value="3" class="bg-gray-800 text-white">📹 Camera 3</option>
            <option value="4" class="bg-gray-800 text-white">📹 Camera 4</option>
          </select>
          <button onclick="toggleCamera('right')" class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 border border-white/30 hover:scale-105" id="rightCameraToggle">
            <span class="material-icons text-sm mr-1">play_arrow</span>
            Start
          </button>
          <button onclick="testCameraConnectivity()" class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 px-3 py-2 rounded-lg text-sm transition-all duration-200 border border-white/30" title="Test Connection">
            <span class="material-icons text-sm">wifi_find</span>
          </button>
          <button class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 p-2 rounded-lg drag-handle transition-all duration-200 border border-white/30">
            <span class="material-icons">drag_indicator</span>
          </button>
        </div>
      </div>
      <div class="h-full bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-900 flex items-center justify-center relative overflow-hidden">
        <div class="absolute inset-0 bg-gradient-to-br from-green-500/5 to-teal-500/5"></div>
        <div id="rightCameraPlaceholder" class="text-center text-gray-500 dark:text-gray-400 relative z-10 transform transition-all duration-500">
          <div class="bg-gray-200 dark:bg-gray-700 rounded-full p-8 mx-auto mb-4 w-24 h-24 flex items-center justify-center shadow-lg">
            <span class="material-icons text-5xl text-gray-400 dark:text-gray-500 animate-pulse">videocam_off</span>
          </div>
          <p class="text-lg font-medium">Camera Offline</p>
          <p class="text-sm opacity-75 mt-1">Click Start to begin streaming</p>
          <div class="mt-4 text-xs opacity-60">
            <p>💡 Tips:</p>
            <p>• Use test button to check connectivity</p>
            <p>• Press Ctrl+2 to toggle this camera</p>
            <p>• Switch between cameras using dropdown</p>
          </div>
        </div>
        <img id="rightCameraFeed" class="w-full h-full object-contain hidden rounded-lg shadow-inner" alt="Right Camera Feed" />
        <div id="rightCameraOverlay" class="absolute top-4 left-4 bg-black/70 backdrop-blur-sm text-white px-3 py-2 rounded-lg text-sm font-medium hidden">
          <span class="inline-block w-2 h-2 bg-red-500 rounded-full mr-2 animate-pulse"></span>
          LIVE
        </div>
      </div>
    </div>

    <!-- Gallery Map -->
    <div class="bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-xl hover:shadow-2xl transition-all duration-300 draggable-panel overflow-hidden animate-fadeInUp" draggable="true" style="animation-delay: 0.3s">
      <div class="bg-gradient-to-r from-purple-600 via-pink-600 to-rose-600 dark:from-purple-700 dark:via-pink-700 dark:to-rose-700 p-4 flex items-center justify-between relative">
        <div class="absolute inset-0 bg-gradient-to-r from-purple-400/20 to-pink-400/20 blur-xl"></div>
        <h3 class="text-white font-bold flex items-center relative z-10">
          <div class="bg-white/20 p-2 rounded-lg mr-3 backdrop-blur-sm">
            <span class="material-icons text-white">map</span>
          </div>
          Gallery Map
        </h3>
        <div class="flex gap-3 relative z-10">
          <button id="togglePathsBtn" onclick="togglePaths()" class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 border border-white/30 hover:scale-105">
            <span class="material-icons text-sm mr-1">route</span>
            Hide Paths
          </button>
          <button onclick="initializeAllCameras()" class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 border border-white/30 hover:scale-105" title="Initialize All Cameras">
            <span class="material-icons text-sm mr-1">videocam</span>
            Init
          </button>
          <button class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 p-2 rounded-lg drag-handle transition-all duration-200 border border-white/30">
            <span class="material-icons">drag_indicator</span>
          </button>
        </div>
      </div>
      <div class="h-full relative bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-900">
        <div class="absolute inset-0 bg-gradient-to-br from-purple-500/5 to-pink-500/5"></div>
        <canvas id="mapCanvas" class="w-full h-full relative z-10"></canvas>
      </div>
    </div>

    <!-- Robot Management -->
    <div class="bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-xl hover:shadow-2xl transition-all duration-300 draggable-panel overflow-hidden animate-fadeInUp" draggable="true" style="animation-delay: 0.4s">
      <div class="bg-gradient-to-r from-orange-600 via-red-600 to-pink-600 dark:from-orange-700 dark:via-red-700 dark:to-pink-700 p-4 flex items-center justify-between relative">
        <div class="absolute inset-0 bg-gradient-to-r from-orange-400/20 to-red-400/20 blur-xl"></div>
        <h2 class="text-white font-bold flex items-center relative z-10">
          <div class="bg-white/20 p-2 rounded-lg mr-3 backdrop-blur-sm">
            <span class="material-icons text-white">smart_toy</span>
          </div>
          Robot Fleet Management
        </h2>
        <button class="bg-white/20 backdrop-blur-sm text-white hover:bg-white/30 p-2 rounded-lg drag-handle transition-all duration-200 border border-white/30">
          <span class="material-icons">drag_indicator</span>
        </button>
      </div>
      
      <div class="p-6 h-full overflow-y-auto bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-900">
        <div class="absolute inset-0 bg-gradient-to-br from-orange-500/5 to-red-500/5 pointer-events-none"></div>
        <!-- Robot Groups -->
        <div id="robotGroups" class="space-y-4 relative z-10">
          
          <!-- Production Group -->
          <div class="robot-group bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600 draggable-group" draggable="true">
            <div class="group-header p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 rounded-t-lg flex items-center justify-between" onclick="toggleGroup('production')">
              <div class="flex items-center">
                <span class="material-icons mr-2 text-blue-600 dark:text-blue-400 group-chevron">expand_more</span>
                <span class="font-bold text-gray-800 dark:text-gray-200 editable-text cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 px-2 py-1 rounded" onclick="editText(this, event)">Production Robots</span>
                <span class="ml-2 text-sm text-gray-500 dark:text-gray-400">(3 robots)</span>
              </div>
              <button class="text-gray-500 hover:bg-gray-200 dark:hover:bg-gray-500 p-1 rounded drag-handle" onclick="event.stopPropagation()">
                <span class="material-icons">drag_indicator</span>
              </button>
            </div>
            
            <div id="production-robots" class="group-content space-y-2 p-3 pt-0">
              <!-- Robot Alpha - Active/Running -->
              <div class="robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center draggable-robot" draggable="true">
                <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
                  <span class="material-icons text-sm">drag_indicator</span>
                </button>
                <div class="flex-1 grid grid-cols-4 gap-4 items-center">
                  <div class="flex items-center">
                    <span class="text-2xl mr-2">🟢</span>
                    <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editText(this, event)">Robot Alpha</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Path: <span class="font-medium text-green-600 dark:text-green-400">Gallery Tour A</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Battery: <span class="font-medium">85%</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Uptime: <span class="font-medium">2h 15m</span>
                  </div>
                </div>
              </div>

              <!-- Robot Beta - Idle/Inactive -->
              <div class="robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center draggable-robot" draggable="true">
                <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
                  <span class="material-icons text-sm">drag_indicator</span>
                </button>
                <div class="flex-1 grid grid-cols-4 gap-4 items-center">
                  <div class="flex items-center">
                    <span class="text-2xl mr-2">🌙</span>
                    <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editText(this, event)">Robot Beta</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Path: <span class="font-medium text-yellow-600 dark:text-yellow-400">Idle</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Battery: <span class="font-medium">92%</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Uptime: <span class="font-medium">45m</span>
                  </div>
                </div>
              </div>

              <!-- Robot Gamma - Serious Issue -->
              <div class="robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center draggable-robot" draggable="true">
                <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
                  <span class="material-icons text-sm">drag_indicator</span>
                </button>
                <div class="flex-1 grid grid-cols-4 gap-4 items-center">
                  <div class="flex items-center">
                    <span class="text-2xl mr-2">⚠️</span>
                    <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editText(this, event)">Robot Gamma</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Path: <span class="font-medium text-red-600 dark:text-red-400">Gallery Tour B</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Battery: <span class="font-medium">67%</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Issue: <span class="font-medium text-red-600 dark:text-red-400">Navigation Error</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Testing Group (Collapsed) -->
          <div class="robot-group bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600 draggable-group" draggable="true">
            <div class="group-header p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600 rounded-t-lg flex items-center justify-between" onclick="toggleGroup('testing')">
              <div class="flex items-center">
                <span class="material-icons mr-2 text-purple-600 dark:text-purple-400 group-chevron">chevron_right</span>
                <span class="font-bold text-gray-800 dark:text-gray-200 editable-text cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 px-2 py-1 rounded" onclick="editText(this, event)">Testing Robots</span>
                <span class="ml-2 text-sm text-gray-500 dark:text-gray-400">(2 robots)</span>
              </div>
              <button class="text-gray-500 hover:bg-gray-200 dark:hover:bg-gray-500 p-1 rounded drag-handle" onclick="event.stopPropagation()">
                <span class="material-icons">drag_indicator</span>
              </button>
            </div>
            
            <div id="testing-robots" class="group-content space-y-2 p-3 pt-0 hidden">
              <!-- Robot Delta - Offline -->
              <div class="robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center draggable-robot" draggable="true">
                <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
                  <span class="material-icons text-sm">drag_indicator</span>
                </button>
                <div class="flex-1 grid grid-cols-4 gap-4 items-center">
                  <div class="flex items-center">
                    <span class="text-2xl mr-2">🛑</span>
                    <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editText(this, event)">Robot Delta</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Path: <span class="font-medium text-gray-500">--</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Battery: <span class="font-medium">--</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Status: <span class="font-medium text-red-600 dark:text-red-400">Offline</span>
                  </div>
                </div>
              </div>

              <!-- Robot Echo - Minor Issue -->
              <div class="robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center draggable-robot" draggable="true">
                <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
                  <span class="material-icons text-sm">drag_indicator</span>
                </button>
                <div class="flex-1 grid grid-cols-4 gap-4 items-center">
                  <div class="flex items-center">
                    <span class="text-2xl mr-2">❗</span>
                    <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editText(this, event)">Robot Echo</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Path: <span class="font-medium text-orange-600 dark:text-orange-400">Test Route B</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Battery: <span class="font-medium">78%</span>
                  </div>
                  <div class="text-sm text-gray-600 dark:text-gray-400">
                    Warning: <span class="font-medium text-orange-600 dark:text-orange-400">Low Speed</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Ungrouped Robots -->
          <div class="mt-4">
            <h3 class="text-lg font-bold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
              <span class="material-icons mr-2">scatter_plot</span>
              Ungrouped Robots
            </h3>
            
            <!-- Robot Zeta - Standby -->
            <div class="robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center mb-2 draggable-robot" draggable="true">
              <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
                <span class="material-icons text-sm">drag_indicator</span>
              </button>
              <div class="flex-1 grid grid-cols-4 gap-4 items-center">
                <div class="flex items-center">
                  <span class="text-2xl mr-2">🟡</span>
                  <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editText(this, event)">Robot Zeta</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                  Path: <span class="font-medium text-yellow-600 dark:text-yellow-400">Standby</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                  Battery: <span class="font-medium">100%</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                  Status: <span class="font-medium text-green-600 dark:text-green-400">Ready</span>
                </div>
              </div>
            </div>

            <!-- Robot Theta - Sleeping/Inactive -->
            <div class="robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center mb-2 draggable-robot" draggable="true">
              <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
                <span class="material-icons text-sm">drag_indicator</span>
              </button>
              <div class="flex-1 grid grid-cols-4 gap-4 items-center">
                <div class="flex items-center">
                  <span class="text-2xl mr-2">💤</span>
                  <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editText(this, event)">Robot Theta</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                  Path: <span class="font-medium text-gray-500">Sleep Mode</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                  Battery: <span class="font-medium">95%</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400">
                  Status: <span class="font-medium text-blue-600 dark:text-blue-400">Charging</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let showPaths = true;
    let draggedElement = null;
    let robotData = {};
    let mapData = {};
    let activeCameras = {
      left: { id: '1', active: false, connecting: false },
      right: { id: '2', active: false, connecting: false }
    };

    // Camera functions
    async function toggleCamera(position) {
      const cameraId = activeCameras[position].id;
      const isActive = activeCameras[position].active;
      const isConnecting = activeCameras[position].connecting;
      const toggleBtn = document.getElementById(`${position}CameraToggle`);
      const feed = document.getElementById(`${position}CameraFeed`);
      const placeholder = document.getElementById(`${position}CameraPlaceholder`);
      const overlay = document.getElementById(`${position}CameraOverlay`);

      if (isConnecting) {
        showNotification(`Camera ${cameraId} is already connecting...`, 'warning');
        return;
      }

      try {
        if (isActive) {
          // Stop camera
          showNotification(`Stopping Camera ${cameraId}...`, 'info');
          await fetch(`/api/camera/${cameraId}/stop`, { method: 'POST' });
          activeCameras[position].active = false;
          toggleBtn.innerHTML = '<span class="material-icons text-sm mr-1">play_arrow</span>Start';
          toggleBtn.classList.remove('bg-red-500/20', 'hover:bg-red-500/30');
          toggleBtn.classList.add('bg-white/20', 'hover:bg-white/30');
          feed.classList.add('hidden');
          placeholder.classList.remove('hidden');
          overlay.classList.add('hidden');
          feed.src = '';
          showNotification(`Camera ${cameraId} stopped`, 'success');
        } else {
          // Start camera
          activeCameras[position].connecting = true;
          toggleBtn.innerHTML = '<span class="material-icons text-sm mr-1 animate-spin">refresh</span>Connecting...';
          toggleBtn.disabled = true;
          
          showNotification(`Starting Camera ${cameraId}...`, 'info');
          
          const response = await fetch(`/api/camera/${cameraId}/start`, { method: 'POST' });
          
          if (response.ok) {
            activeCameras[position].active = true;
            activeCameras[position].connecting = false;
            toggleBtn.innerHTML = '<span class="material-icons text-sm mr-1">stop</span>Stop';
            toggleBtn.disabled = false;
            toggleBtn.classList.add('bg-red-500/20', 'hover:bg-red-500/30');
            toggleBtn.classList.remove('bg-white/20', 'hover:bg-white/30');
            
            // Wait a bit for the stream to initialize
            setTimeout(() => {
              feed.src = `/api/camera/${cameraId}/stream?t=${Date.now()}`;
              feed.classList.remove('hidden');
              placeholder.classList.add('hidden');
              overlay.classList.remove('hidden');
              showNotification(`Camera ${cameraId} connected successfully!`, 'success');
            }, 1000);
            
            // Handle stream errors
            feed.onerror = () => {
              console.error(`Error loading camera ${cameraId} feed`);
              showNotification(`Failed to load Camera ${cameraId} feed`, 'error');
              resetCameraState(position);
            };
            
            // Handle stream load success
            feed.onload = () => {
              showNotification(`Camera ${cameraId} stream loaded`, 'success');
            };
          } else {
            const errorData = await response.json();
            showNotification(`Failed to start Camera ${cameraId}: ${errorData.error || 'Unknown error'}`, 'error');
            resetCameraState(position);
          }
        }
      } catch (error) {
        console.error(`Error toggling camera ${cameraId}:`, error);
        showNotification(`Error connecting to Camera ${cameraId}: ${error.message}`, 'error');
        resetCameraState(position);
      }
    }

    function resetCameraState(position) {
      const toggleBtn = document.getElementById(`${position}CameraToggle`);
      const feed = document.getElementById(`${position}CameraFeed`);
      const placeholder = document.getElementById(`${position}CameraPlaceholder`);
      const overlay = document.getElementById(`${position}CameraOverlay`);
      
      activeCameras[position].active = false;
      activeCameras[position].connecting = false;
      toggleBtn.innerHTML = '<span class="material-icons text-sm mr-1">play_arrow</span>Start';
      toggleBtn.disabled = false;
      toggleBtn.classList.remove('bg-red-500/20', 'hover:bg-red-500/30');
      toggleBtn.classList.add('bg-white/20', 'hover:bg-white/30');
      feed.classList.add('hidden');
      placeholder.classList.remove('hidden');
      overlay.classList.add('hidden');
      feed.src = '';
    }

    async function switchCamera(position, newCameraId) {
      // Stop current camera if active
      if (activeCameras[position].active) {
        showNotification(`Switching from Camera ${activeCameras[position].id} to Camera ${newCameraId}...`, 'info');
        await toggleCamera(position);
        // Wait a bit before starting the new camera
        setTimeout(async () => {
          activeCameras[position].id = newCameraId;
          await toggleCamera(position);
        }, 500);
      } else {
        // Just update camera ID
        activeCameras[position].id = newCameraId;
        showNotification(`Selected Camera ${newCameraId} for ${position} panel`, 'info');
      }
    }

    async function checkCameraStatus() {
      // Check status of all cameras and update UI
      for (const position in activeCameras) {
        const cameraId = activeCameras[position].id;
        try {
          const response = await fetch(`/api/camera/${cameraId}/status`);
          const status = await response.json();
          
          const toggleBtn = document.getElementById(`${position}CameraToggle`);
          const overlay = document.getElementById(`${position}CameraOverlay`);
          
          if (status.status === 'online' && !activeCameras[position].active) {
            // Camera is running but UI thinks it's off - sync state
            activeCameras[position].active = true;
            toggleBtn.innerHTML = '<span class="material-icons text-sm mr-1">stop</span>Stop';
            toggleBtn.classList.add('bg-red-500/20', 'hover:bg-red-500/30');
            toggleBtn.classList.remove('bg-white/20', 'hover:bg-white/30');
            
            const feed = document.getElementById(`${position}CameraFeed`);
            const placeholder = document.getElementById(`${position}CameraPlaceholder`);
            feed.src = `/api/camera/${cameraId}/stream?t=${Date.now()}`;
            feed.classList.remove('hidden');
            placeholder.classList.add('hidden');
            overlay.classList.remove('hidden');
          }
        } catch (error) {
          console.error(`Error checking camera ${cameraId} status:`, error);
        }
      }
    }

    // Notification system
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full`;
      
      const colors = {
        success: 'bg-green-500 text-white',
        error: 'bg-red-500 text-white',
        warning: 'bg-yellow-500 text-black',
        info: 'bg-blue-500 text-white'
      };
      
      const icons = {
        success: 'check_circle',
        error: 'error',
        warning: 'warning',
        info: 'info'
      };
      
      notification.className += ` ${colors[type] || colors.info}`;
      notification.innerHTML = `
        <div class="flex items-center">
          <span class="material-icons mr-2">${icons[type] || icons.info}</span>
          <span>${message}</span>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.classList.remove('translate-x-full');
      }, 100);
      
      // Auto remove after 4 seconds
      setTimeout(() => {
        notification.classList.add('translate-x-full');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 4000);
    }
    
    // Test camera connectivity
    async function testCameraConnectivity() {
      showNotification('Testing camera connectivity...', 'info');
      try {
        const response = await fetch('/api/cameras/test');
        const data = await response.json();
        
        let successCount = 0;
        let totalCount = 0;
        
        for (const [cameraId, result] of Object.entries(data.results)) {
          totalCount++;
          if (result.accessible) {
            successCount++;
          }
        }
        
        if (successCount === totalCount) {
          showNotification(`All ${totalCount} cameras are accessible!`, 'success');
        } else if (successCount > 0) {
          showNotification(`${successCount}/${totalCount} cameras accessible`, 'warning');
        } else {
          showNotification('No cameras are accessible. Check RTSP server.', 'error');
        }
        
        return data.results;
      } catch (error) {
        showNotification('Failed to test camera connectivity', 'error');
        return null;
      }
    }

    // Initialize all cameras
    async function initializeAllCameras() {
      showNotification('Initializing all cameras...', 'info');
      try {
        const response = await fetch('/api/cameras/init', { method: 'POST' });
        const data = await response.json();
        
        let successCount = 0;
        let totalCount = 0;
        
        for (const [cameraId, result] of Object.entries(data.results)) {
          totalCount++;
          if (result.success) {
            successCount++;
          }
        }
        
        if (successCount === totalCount) {
          showNotification(`All ${totalCount} cameras initialized successfully!`, 'success');
        } else if (successCount > 0) {
          showNotification(`${successCount}/${totalCount} cameras initialized`, 'warning');
        } else {
          showNotification('Failed to initialize cameras. Check RTSP server.', 'error');
        }
        
        // Update UI to reflect current states
        setTimeout(checkCameraStatus, 1000);
        
      } catch (error) {
        console.error('Error initializing cameras:', error);
        showNotification('Failed to initialize cameras', 'error');
      }
    }

    // Add demo mode for testing without real cameras
    async function enableDemoMode() {
      showNotification('Enabling demo mode with test feeds...', 'info');
      
      // Create test patterns or use placeholder videos
      const testFeeds = {
        left: 'data:image/svg+xml;base64,' + btoa(`
          <svg width="640" height="480" xmlns="http://www.w3.org/2000/svg">
            <rect width="640" height="480" fill="#1e293b"/>
            <text x="320" y="240" text-anchor="middle" fill="white" font-size="24" font-family="Arial">
              Demo Camera 1
            </text>
            <circle cx="320" cy="300" r="20" fill="#10b981" opacity="0.8">
              <animate attributeName="opacity" values="0.8;0.3;0.8" dur="2s" repeatCount="indefinite"/>
            </circle>
          </svg>
        `),
        right: 'data:image/svg+xml;base64,' + btoa(`
          <svg width="640" height="480" xmlns="http://www.w3.org/2000/svg">
            <rect width="640" height="480" fill="#1e293b"/>
            <text x="320" y="240" text-anchor="middle" fill="white" font-size="24" font-family="Arial">
              Demo Camera 2
            </text>
            <circle cx="320" cy="300" r="20" fill="#3b82f6" opacity="0.8">
              <animate attributeName="opacity" values="0.8;0.3;0.8" dur="1.5s" repeatCount="indefinite"/>
            </circle>
          </svg>
        `)
      };
      
      // Simulate camera feeds
      for (const [position, feedData] of Object.entries(testFeeds)) {
        const feed = document.getElementById(`${position}CameraFeed`);
        const placeholder = document.getElementById(`${position}CameraPlaceholder`);
        const overlay = document.getElementById(`${position}CameraOverlay`);
        const toggleBtn = document.getElementById(`${position}CameraToggle`);
        
        feed.src = feedData;
        feed.classList.remove('hidden');
        placeholder.classList.add('hidden');
        overlay.classList.remove('hidden');
        
        toggleBtn.innerHTML = '<span class="material-icons text-sm mr-1">stop</span>Demo';
        toggleBtn.classList.add('bg-orange-500/20', 'hover:bg-orange-500/30');
        toggleBtn.classList.remove('bg-white/20', 'hover:bg-white/30');
        
        activeCameras[position].active = true;
      }
      
      showNotification('Demo mode enabled! Showing test camera feeds.', 'success');
    }

    // Add connection health monitoring
    let connectionHealthTimer;
    
    function startConnectionHealthMonitoring() {
      connectionHealthTimer = setInterval(async () => {
        for (const position in activeCameras) {
          if (activeCameras[position].active) {
            const feed = document.getElementById(`${position}CameraFeed`);
            const overlay = document.getElementById(`${position}CameraOverlay`);
            
            // Check if the image is still loading
            if (feed.complete === false) {
              // Image is still loading or failed to load
              overlay.innerHTML = `
                <span class="inline-block w-2 h-2 bg-yellow-500 rounded-full mr-2 animate-pulse"></span>
                RECONNECTING
              `;
              overlay.className = overlay.className.replace('bg-black/70', 'bg-yellow-600/70');
            } else {
              // Image loaded successfully
              overlay.innerHTML = `
                <span class="inline-block w-2 h-2 bg-red-500 rounded-full mr-2 animate-pulse"></span>
                LIVE
              `;
              overlay.className = overlay.className.replace('bg-yellow-600/70', 'bg-black/70');
            }
          }
        }
      }, 5000); // Check every 5 seconds
    }
    
    function stopConnectionHealthMonitoring() {
      if (connectionHealthTimer) {
        clearInterval(connectionHealthTimer);
      }
    }

    // API functions
    async function fetchRobotData() {
      try {
        const response = await fetch('/api/robots');
        const data = await response.json();
        robotData = data;
        updateRobotDisplay();
        updateMap();
      } catch (error) {
        console.error('Error fetching robot data:', error);
      }
    }

    async function fetchMapData() {
      try {
        const response = await fetch('/api/map');
        mapData = await response.json();
        updateMap();
      } catch (error) {
        console.error('Error fetching map data:', error);
      }
    }

    async function updateRobotName(robotId, newName) {
      try {
        const response = await fetch(`/api/robots/${robotId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ name: newName })
        });
        if (response.ok) {
          console.log('Robot name updated successfully');
        }
      } catch (error) {
        console.error('Error updating robot name:', error);
      }
    }

    async function moveRobotToGroup(robotId, groupId) {
      try {
        const response = await fetch(`/api/robots/${robotId}/move`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ group: groupId })
        });
        if (response.ok) {
          console.log('Robot moved successfully');
          fetchRobotData(); // Refresh data
        }
      } catch (error) {
        console.error('Error moving robot:', error);
      }
    }

    async function updateCameraName(cameraId, newName) {
      try {
        const response = await fetch(`/api/cameras/${cameraId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ name: newName })
        });
        if (response.ok) {
          console.log('Camera name updated successfully');
        }
      } catch (error) {
        console.error('Error updating camera name:', error);
      }
    }

    function updateRobotDisplay() {
      if (!robotData.robots) return;

      // Update production group
      const productionContainer = document.getElementById('production-robots');
      if (productionContainer) {
        const productionRobots = robotData.robots.filter(r => r.group === 'production');
        updateRobotGroup(productionContainer, productionRobots);
      }

      // Update testing group
      const testingContainer = document.getElementById('testing-robots');
      if (testingContainer) {
        const testingRobots = robotData.robots.filter(r => r.group === 'testing');
        updateRobotGroup(testingContainer, testingRobots);
      }

      // Update ungrouped robots
      const ungroupedContainer = document.querySelector('.mt-4');
      if (ungroupedContainer) {
        const ungroupedRobots = robotData.robots.filter(r => r.group === 'ungrouped');
        updateUngroupedRobots(ungroupedContainer, ungroupedRobots);
      }
    }

    function updateRobotGroup(container, robots) {
      container.innerHTML = '';
      robots.forEach(robot => {
        const robotElement = createRobotElement(robot);
        container.appendChild(robotElement);
      });
    }

    function updateUngroupedRobots(container, robots) {
      // Remove existing robot elements but keep the header
      const existingRobots = container.querySelectorAll('.robot-item');
      existingRobots.forEach(el => el.remove());

      robots.forEach(robot => {
        const robotElement = createRobotElement(robot);
        container.appendChild(robotElement);
      });
    }

    function createRobotElement(robot) {
      const div = document.createElement('div');
      div.className = 'robot-item bg-white dark:bg-gray-800 p-3 rounded border border-gray-200 dark:border-gray-600 flex items-center mb-2 draggable-robot';
      div.setAttribute('draggable', 'true');
      div.setAttribute('data-robot-id', robot.id);

      const statusColor = getStatusColor(robot.status);
      const pathText = robot.path || '--';
      const batteryText = robot.battery !== undefined ? `${robot.battery}%` : '--';
      const extraInfo = getExtraInfo(robot);

      div.innerHTML = `
        <button class="text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded mr-3 drag-handle">
          <span class="material-icons text-sm">drag_indicator</span>
        </button>
        <div class="flex-1 grid grid-cols-4 gap-4 items-center">
          <div class="flex items-center">
            <span class="text-2xl mr-2">${robot.emoji}</span>
            <span class="font-medium editable-text cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 py-1 rounded" onclick="editRobotText(this, event, '${robot.id}')">${robot.name}</span>
          </div>
          <div class="text-sm text-gray-600 dark:text-gray-400">
            Path: <span class="font-medium ${statusColor}">${pathText}</span>
          </div>
          <div class="text-sm text-gray-600 dark:text-gray-400">
            Battery: <span class="font-medium">${batteryText}</span>
          </div>
          <div class="text-sm text-gray-600 dark:text-gray-400">
            ${extraInfo}
          </div>
        </div>
      `;

      return div;
    }

    function getStatusColor(status) {
      switch (status) {
        case 'active': return 'text-green-600 dark:text-green-400';
        case 'idle': return 'text-yellow-600 dark:text-yellow-400';
        case 'error': return 'text-red-600 dark:text-red-400';
        case 'warning': return 'text-orange-600 dark:text-orange-400';
        case 'offline': return 'text-gray-500';
        default: return 'text-blue-600 dark:text-blue-400';
      }
    }

    function getExtraInfo(robot) {
      if (robot.issue) {
        const color = robot.status === 'error' ? 'text-red-600 dark:text-red-400' : 'text-orange-600 dark:text-orange-400';
        return `Issue: <span class="font-medium ${color}">${robot.issue}</span>`;
      }
      if (robot.warning) {
        return `Warning: <span class="font-medium text-orange-600 dark:text-orange-400">${robot.warning}</span>`;
      }
      if (robot.status_text) {
        const color = getStatusColor(robot.status);
        return `Status: <span class="font-medium ${color}">${robot.status_text}</span>`;
      }
      if (robot.uptime) {
        return `Uptime: <span class="font-medium">${robot.uptime}</span>`;
      }
      return '';
    }

    // Initialize map canvas
    function initializeMap() {
      const canvas = document.getElementById('mapCanvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      drawMap(ctx, canvas.width, canvas.height);
    }

    function updateMap() {
      const canvas = document.getElementById('mapCanvas');
      const ctx = canvas.getContext('2d');
      drawMap(ctx, canvas.width, canvas.height);
    }

    function drawMap(ctx, width, height) {
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw gallery outline
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 3;
      ctx.strokeRect(20, 20, width - 40, height - 40);
      
      // Draw pillars from API data
      if (mapData.pillars) {
        ctx.fillStyle = '#6b7280';
        mapData.pillars.forEach(pillar => {
          const x = pillar.x * width;
          const y = pillar.y * height;
          ctx.fillRect(x - 8, y - 8, 16, 16);
        });
      }
      
      // Draw robots on map
      drawRobots(ctx, width, height);
      
      // Draw paths if enabled
      if (showPaths) {
        drawPaths(ctx, width, height);
      }
    }

    function drawRobots(ctx, width, height) {
      if (!robotData.robots) return;

      robotData.robots.forEach(robot => {
        if (!robot.position) return;

        const x = robot.position.x * width;
        const y = robot.position.y * height;
        const angle = robot.position.angle || 0;

        // Robot body (circular)
        ctx.fillStyle = getStatusMapColor(robot.status);
        
        ctx.beginPath();
        ctx.arc(x, y, 14, 0, 2 * Math.PI);
        ctx.fill();
        
        // Robot outline
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Robot direction indicator (front-facing line)
        const dirX = x + Math.cos(angle * Math.PI / 180) * 18;
        const dirY = y + Math.sin(angle * Math.PI / 180) * 18;
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(dirX, dirY);
        ctx.stroke();
        
        // Robot name label
        ctx.fillStyle = '#1f2937';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(robot.name.split(' ')[1] || robot.name, x, y - 25);
        ctx.textAlign = 'start';
      });
    }

    function getStatusMapColor(status) {
      switch (status) {
        case 'active': return '#10b981';
        case 'idle': return '#f59e0b';
        case 'error': return '#ef4444';
        case 'warning': return '#f97316';
        case 'standby': return '#eab308';
        case 'sleeping': return '#3b82f6';
        case 'offline': return '#6b7280';
        default: return '#6b7280';
      }
    }

    function drawPaths(ctx, width, height) {
      if (!mapData.paths) return;

      // Draw predicted paths for robots with paths
      Object.entries(mapData.paths).forEach(([robotId, pathPoints]) => {
        const robot = robotData.robots?.find(r => r.id === robotId);
        if (!robot || !pathPoints) return;

        ctx.strokeStyle = getStatusMapColor(robot.status);
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        ctx.beginPath();
        pathPoints.forEach((point, index) => {
          const x = point.x * width;
          const y = point.y * height;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
      });
      
      ctx.setLineDash([]);
    }

    function togglePaths() {
      showPaths = !showPaths;
      const btn = document.getElementById('togglePathsBtn');
      if (showPaths) {
        btn.innerHTML = '<span class="material-icons text-sm mr-1">visibility_off</span>Hide Paths';
        btn.classList.add('bg-yellow-500/20', 'border-yellow-300/30');
        btn.classList.remove('bg-white/20', 'border-white/30');
      } else {
        btn.innerHTML = '<span class="material-icons text-sm mr-1">visibility</span>Show Paths';
        btn.classList.remove('bg-yellow-500/20', 'border-yellow-300/30');
        btn.classList.add('bg-white/20', 'border-white/30');
      }
      
      updateMap();
    }

    function toggleGroup(groupId) {
      const content = document.getElementById(groupId + '-robots');
      const chevron = content.previousElementSibling.querySelector('.group-chevron');
      
      if (content.classList.contains('hidden')) {
        content.classList.remove('hidden');
        chevron.textContent = 'expand_more';
      } else {
        content.classList.add('hidden');
        chevron.textContent = 'chevron_right';
      }
    }

    function editText(element, event) {
      if (event) event.stopPropagation();
      
      const currentText = element.textContent;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentText;
      input.className = 'bg-transparent border-b border-gray-400 outline-none text-inherit font-inherit';
      input.style.minWidth = '100px';
      
      element.replaceWith(input);
      input.focus();
      input.select();
      
      function saveEdit() {
        const newText = input.value || currentText;
        const newSpan = document.createElement('span');
        newSpan.className = element.className;
        newSpan.textContent = newText;
        newSpan.onclick = (e) => editText(newSpan, e);
        input.replaceWith(newSpan);

        // Update camera name via API if this is a camera
        const cameraId = element.closest('.draggable-panel')?.querySelector('[data-camera-id]')?.dataset.cameraId;
        if (cameraId) {
          updateCameraName(cameraId, newText);
        }
      }
      
      input.addEventListener('blur', saveEdit);
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') saveEdit();
      });
    }

    function editRobotText(element, event, robotId) {
      if (event) event.stopPropagation();
      
      const currentText = element.textContent;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentText;
      input.className = 'bg-transparent border-b border-gray-400 outline-none text-inherit font-inherit';
      input.style.minWidth = '100px';
      
      element.replaceWith(input);
      input.focus();
      input.select();
      
      function saveEdit() {
        const newText = input.value || currentText;
        const newSpan = document.createElement('span');
        newSpan.className = element.className;
        newSpan.textContent = newText;
        newSpan.onclick = (e) => editRobotText(newSpan, e, robotId);
        input.replaceWith(newSpan);

        // Update robot name via API
        updateRobotName(robotId, newText);
      }
      
      input.addEventListener('blur', saveEdit);
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') saveEdit();
      });
    }

    // Drag and Drop functionality
    function initializeDragAndDrop() {
      // Panel dragging (camera feeds, map, robot management)
      const panels = document.querySelectorAll('.draggable-panel');
      panels.forEach(panel => {
        const dragHandle = panel.querySelector('.drag-handle');
        
        // Make drag handle draggable
        if (dragHandle) {
          dragHandle.setAttribute('draggable', 'true');
          
          dragHandle.addEventListener('dragstart', (e) => {
            draggedElement = panel;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', panel.outerHTML);
            panel.style.opacity = '0.5';
          });
          
          dragHandle.addEventListener('dragend', (e) => {
            panel.style.opacity = '1';
          });
        }
        
        panel.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        panel.addEventListener('drop', (e) => {
          e.preventDefault();
          if (draggedElement && draggedElement !== panel) {
            // Swap the positions of the panels
            const draggedParent = draggedElement.parentNode;
            const targetParent = panel.parentNode;
            
            if (draggedParent === targetParent) {
              const temp = document.createElement('div');
              draggedParent.insertBefore(temp, draggedElement);
              draggedParent.insertBefore(draggedElement, panel);
              draggedParent.insertBefore(panel, temp);
              draggedParent.removeChild(temp);
            }
          }
        });
      });

      // Robot group dragging
      const groups = document.querySelectorAll('.draggable-group');
      groups.forEach(group => {
        const dragHandle = group.querySelector('.drag-handle');
        
        if (dragHandle) {
          dragHandle.setAttribute('draggable', 'true');
          
          dragHandle.addEventListener('dragstart', (e) => {
            draggedElement = group;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', group.outerHTML);
            group.style.opacity = '0.5';
          });
          
          dragHandle.addEventListener('dragend', (e) => {
            group.style.opacity = '1';
          });
        }
        
        group.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        group.addEventListener('drop', (e) => {
          e.preventDefault();
          if (draggedElement && draggedElement !== group && draggedElement.classList.contains('draggable-group')) {
            const container = group.parentNode;
            const groups = Array.from(container.querySelectorAll('.draggable-group'));
            const draggedIndex = groups.indexOf(draggedElement);
            const targetIndex = groups.indexOf(group);
            
            if (draggedIndex < targetIndex) {
              container.insertBefore(draggedElement, group.nextSibling);
            } else {
              container.insertBefore(draggedElement, group);
            }
          }
        });
      });

      // Robot item dragging - will be set up dynamically when robots are loaded
      setupRobotDragging();

      // Allow dropping robots on groups (for moving between groups)
      groups.forEach(group => {
        group.addEventListener('drop', (e) => {
          e.preventDefault();
          if (draggedElement && draggedElement.classList.contains('draggable-robot')) {
            const robotId = draggedElement.dataset.robotId;
            const groupId = group.querySelector('.group-content').id.replace('-robots', '');
            
            if (robotId && groupId) {
              moveRobotToGroup(robotId, groupId);
            }
            
            const groupContent = group.querySelector('.group-content');
            if (groupContent && !groupContent.contains(draggedElement)) {
              groupContent.appendChild(draggedElement);
              // Make sure the group is expanded when a robot is dropped into it
              if (groupContent.classList.contains('hidden')) {
                groupContent.classList.remove('hidden');
                const chevron = group.querySelector('.group-chevron');
                if (chevron) chevron.textContent = 'expand_more';
              }
            }
          }
        });
      });

      // Allow dropping on ungrouped area
      const ungroupedSection = document.querySelector('.mt-4');
      if (ungroupedSection) {
        ungroupedSection.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        ungroupedSection.addEventListener('drop', (e) => {
          e.preventDefault();
          if (draggedElement && draggedElement.classList.contains('draggable-robot')) {
            const robotId = draggedElement.dataset.robotId;
            if (robotId) {
              moveRobotToGroup(robotId, 'ungrouped');
            }
            ungroupedSection.appendChild(draggedElement);
          }
        });
      }
    }

    function setupRobotDragging() {
      // Set up dragging for dynamically created robot elements
      document.addEventListener('dragstart', (e) => {
        if (e.target.closest('.draggable-robot')) {
          const robot = e.target.closest('.draggable-robot');
          const dragHandle = e.target.closest('.drag-handle');
          
          if (dragHandle) {
            draggedElement = robot;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', robot.outerHTML);
            robot.style.opacity = '0.5';
          }
        }
      });

      document.addEventListener('dragend', (e) => {
        if (e.target.closest('.draggable-robot')) {
          const robot = e.target.closest('.draggable-robot');
          robot.style.opacity = '1';
        }
      });

      document.addEventListener('dragover', (e) => {
        if (e.target.closest('.draggable-robot')) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        }
      });

      document.addEventListener('drop', (e) => {
        if (e.target.closest('.draggable-robot')) {
          e.preventDefault();
          const targetRobot = e.target.closest('.draggable-robot');
          
          if (draggedElement && draggedElement !== targetRobot && draggedElement.classList.contains('draggable-robot')) {
            const targetContainer = targetRobot.closest('.group-content') || targetRobot.parentNode;
            const draggedContainer = draggedElement.closest('.group-content') || draggedElement.parentNode;
            
            // Insert the dragged robot before or after the target robot
            if (targetContainer === draggedContainer) {
              const robots = Array.from(targetContainer.querySelectorAll('.draggable-robot'));
              const draggedIndex = robots.indexOf(draggedElement);
              const targetIndex = robots.indexOf(targetRobot);
              
              if (draggedIndex < targetIndex) {
                targetContainer.insertBefore(draggedElement, targetRobot.nextSibling);
              } else {
                targetContainer.insertBefore(draggedElement, targetRobot);
              }
            } else {
              // Move to different group
              targetContainer.insertBefore(draggedElement, targetRobot.nextSibling);
              
              // Update group via API
              const robotId = draggedElement.dataset.robotId;
              const groupId = targetContainer.id.replace('-robots', '') || 'ungrouped';
              if (robotId) {
                moveRobotToGroup(robotId, groupId);
              }
            }
          }
        }
      });
    }

    // Auto-refresh data every 30 seconds
    function startAutoRefresh() {
      setInterval(() => {
        fetchRobotData();
        checkCameraStatus();
      }, 30000); // 30 seconds
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Show welcome message
      showNotification('Camera monitoring system loaded', 'success');
      
      initializeMap();
      initializeDragAndDrop();
      
      // Load initial data
      fetchRobotData();
      fetchMapData();
      
      // Check camera status on startup
      setTimeout(() => {
        checkCameraStatus();
        // Test connectivity automatically
        testCameraConnectivity();
      }, 1000);
      
      // Start connection health monitoring
      startConnectionHealthMonitoring();
      
      // Start auto-refresh
      startAutoRefresh();
      
      // Add keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case '1':
              e.preventDefault();
              toggleCamera('left');
              break;
            case '2':
              e.preventDefault();
              toggleCamera('right');
              break;
            case 'd':
              e.preventDefault();
              enableDemoMode();
              break;
            case 't':
              e.preventDefault();
              testCameraConnectivity();
              break;
          }
        }
      });
      
      // Add demo mode button if no cameras are accessible after 5 seconds
      setTimeout(async () => {
        const hasActiveCameras = Object.values(activeCameras).some(cam => cam.active);
        if (!hasActiveCameras) {
          showNotification('No cameras detected. Press Ctrl+D for demo mode.', 'info');
        }
      }, 5000);
      
      // Redraw map on window resize
      window.addEventListener('resize', () => {
        setTimeout(() => {
          initializeMap();
          updateMap();
        }, 100);
      });
      
      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        stopConnectionHealthMonitoring();
      });
    });
  </script>

{% endblock %}
