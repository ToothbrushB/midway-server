{% extends 'base.html' %}

{% block header %}
  <h1>{% block title %}Design{% endblock %}</h1>
{% endblock %}

{% block content %}
  <noscript>
    <div class="bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-600 text-red-700 dark:text-red-200 px-4 py-3 rounded mb-4">
      <p><strong>Warning:</strong> JavaScript is disabled in your browser. This website will not function correctly without JavaScript enabled.</p>
      <p>Please use a browser with JavaScript enabled for the best experience.</p>
    </div>
  </noscript>

  <div class="flex flex-col lg:flex-row gap-6 h-screen">
    <!-- Left Panel - Controls -->
    <div class="lg:w-1/3 xl:w-1/4 bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 overflow-y-auto border border-gray-200 dark:border-gray-700">
      <!-- Header -->
      <div class="mb-6">
        <h2 class="text-2xl font-bold text-green-700 dark:text-green-400 mb-4">Catmull-Rom Spline Path Editor</h2>
        <div class="relative group">
          <button class="flex items-center text-gray-600 dark:text-gray-400 hover:text-green-700 dark:hover:text-green-400 transition-colors">
            <span class="material-icons mr-2">help_outline</span>
            <span class="text-sm">About This App</span>
          </button>
          <div class="absolute left-0 top-8 w-80 bg-gray-800 dark:bg-gray-900 text-white dark:text-gray-200 p-4 rounded-lg shadow-xl opacity-0 pointer-events-none group-hover:opacity-100 group-hover:pointer-events-auto transition-opacity duration-300 z-50 border border-gray-700 dark:border-gray-600">
            <h4 class="font-bold mb-2">About This App</h4>
            <p class="text-sm mb-2">Upload a background image and define smooth paths using Catmull-Rom splines by clicking to add control points.</p>
            <p class="text-sm font-semibold mb-2">Features:</p>
            <ul class="text-xs space-y-1">
              <li>• Upload background images (maps, floor plans)</li>
              <li>• Click to add path points with smooth spline connections</li>
              <li>• Set scale for real-world integration</li>
              <li>• Export paths as CSV files</li>
              <li>• Move and snap dots to grid</li>
              <li>• Robot simulation along the path</li>
            </ul>
          </div>
        </div>
      </div>
      
      <!-- Controls -->
      <div class="space-y-6">
        <!-- File & Background -->
        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 border border-gray-200 dark:border-gray-600">
          <h4 class="font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
            <span class="material-icons mr-2 text-blue-600 dark:text-blue-400">image</span>
            File & Background
          </h4>
          <div class="space-y-3">
            <label class="block">
              <div class="flex items-center justify-center w-full p-3 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer hover:border-blue-500 dark:hover:border-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900 transition-colors">
                <span class="material-icons mr-2 text-blue-600 dark:text-blue-400">upload_file</span>
                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Upload Background</span>
              </div>
              <input type="file" id="bgUpload" accept="image/*" class="hidden">
            </label>
            <div class="flex items-center space-x-2">
              <span class="material-icons text-gray-600 dark:text-gray-400">straighten</span>
              <label class="flex-1">
                <span class="text-sm text-gray-700 dark:text-gray-300">Scale (px/unit):</span>
                <input type="number" id="scaleInput" value="1" class="w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-blue-500 dark:focus:border-blue-400 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
              </label>
            </div>
          </div>
        </div>
        
        <!-- Path Controls -->
        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 border border-gray-200 dark:border-gray-600">
          <h4 class="font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
            <span class="material-icons mr-2 text-green-600 dark:text-green-400">timeline</span>
            Path Controls
          </h4>
          <div class="space-y-2">
            <button onclick="clearPoints()" class="w-full flex items-center justify-center px-4 py-2 bg-red-500 hover:bg-red-600 dark:bg-red-600 dark:hover:bg-red-700 text-white rounded-md transition-colors">
              <span class="material-icons mr-2">clear_all</span>
              <span class="text-sm">Clear Points</span>
            </button>
            <button onclick="undobutton()" class="w-full flex items-center justify-center px-4 py-2 bg-yellow-500 hover:bg-yellow-600 dark:bg-yellow-600 dark:hover:bg-yellow-700 text-white rounded-md transition-colors">
              <span class="material-icons mr-2">undo</span>
              <span class="text-sm">Undo Last Dot</span>
            </button>
            <button onclick="exportPathCSV()" class="w-full flex items-center justify-center px-4 py-2 bg-green-500 hover:bg-green-600 dark:bg-green-600 dark:hover:bg-green-700 text-white rounded-md transition-colors">
              <span class="material-icons mr-2">download</span>
              <span class="text-sm">Export CSV</span>
            </button>
          </div>
        </div>
        
        <!-- Editing Tools -->
        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 border border-gray-200 dark:border-gray-600">
          <h4 class="font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
            <span class="material-icons mr-2 text-purple-600 dark:text-purple-400">edit</span>
            Editing Tools
          </h4>
          <div class="space-y-2">
            <button id="moveDotsBtn" onclick="toggleMoveDotsMode()" class="w-full flex items-center justify-center px-4 py-2 bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white rounded-md transition-colors">
              <span class="material-icons mr-2">open_with</span>
              <span class="text-sm">Move Dots</span>
            </button>
            <button id="snapToGridBtn" onclick="toggleSnapToGrid()" class="w-full flex items-center justify-center px-4 py-2 bg-indigo-500 hover:bg-indigo-600 dark:bg-indigo-600 dark:hover:bg-indigo-700 text-white rounded-md transition-colors">
              <span class="material-icons mr-2">grid_on</span>
              <span class="text-sm">Snap to Grid</span>
            </button>
          </div>
        </div>
        
        <!-- Robot Simulation -->
        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 border border-gray-200 dark:border-gray-600">
          <h4 class="font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
            <span class="material-icons mr-2 text-orange-600 dark:text-orange-400">smart_toy</span>
            Robot Simulation
          </h4>
          <div class="space-y-4">
            <button id="startRobotBtn" onclick="toggleRobotSimulation()" class="w-full flex items-center justify-center px-4 py-2 bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white rounded-md transition-colors">
              <span class="material-icons mr-2">smart_toy</span>
              <span class="text-sm">Start Robot</span>
            </button>
            <div class="space-y-2">
              <label class="flex items-center text-sm text-gray-700 dark:text-gray-300">
                <span class="material-icons mr-2">speed</span>
                Robot Speed:
              </label>
              <div class="flex items-center space-x-3">
                <span class="text-xs text-gray-500 dark:text-gray-400">Slow</span>
                <input type="range" id="robotSpeedSlider" min=".5" max="5" value=".5" 
                       oninput="updateRobotSpeed(this.value)" 
                       class="flex-1 h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer slider">
                <span class="text-xs text-gray-500 dark:text-gray-400">Fast</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Panel - Canvas -->
    <div class="flex-1 bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 border border-gray-200 dark:border-gray-700">
      <div class="h-full flex flex-col">
        <div class="mb-4">
          <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200">Canvas</h3>
          <p class="text-sm text-gray-600 dark:text-gray-400">Click to add points and create smooth paths</p>
        </div>
        <div class="flex-1 border-2 border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden bg-gray-50 dark:bg-gray-700">
          <canvas id="canvas" class="w-full h-full cursor-crosshair"></canvas>
        </div>
      </div>
    </div>
  </div>

  <style>
    /* Custom slider styling */
    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #f97316;
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .dark .slider::-webkit-slider-thumb {
      background: #fb923c;
      border: 2px solid #374151;
    }
    
    .slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #f97316;
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .dark .slider::-moz-range-thumb {
      background: #fb923c;
      border: 2px solid #374151;
    }
    
    /* Responsive canvas */
    #canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    /* Dark mode active button states */
    .dark .bg-blue-700 {
      background-color: #1d4ed8 !important;
    }
    
    .dark .hover\:bg-blue-800:hover {
      background-color: #1e40af !important;
    }
    
    .dark .bg-indigo-700 {
      background-color: #4338ca !important;
    }
    
    .dark .hover\:bg-indigo-800:hover {
      background-color: #3730a3 !important;
    }
    
    .dark .bg-red-500 {
      background-color: #dc2626 !important;
    }
    
    .dark .hover\:bg-red-600:hover {
      background-color: #b91c1c !important;
    }
  </style>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let bgImage = new Image();
    let points = [];
    let shapes = [];
    let moveDotsMode = false;
    let draggingPointIndex = null;
    let snapToGrid = false;
    let gridSize = 20; // Grid spacing in pixels
    let robotSimulation = false;
    let robotPosition = { x: 0, y: 0 };
    let robotProgress = 0;
    let robotAnimationId = null;
    let robotSpeed = 0.005; // How fast the robot moves along the path
    let scale = 1;

    function toggleSnapToGrid() {
      snapToGrid = !snapToGrid;
      const btn = document.getElementById('snapToGridBtn');
      if (snapToGrid) {
        btn.classList.remove('bg-indigo-500', 'hover:bg-indigo-600');
        btn.classList.add('bg-indigo-700', 'hover:bg-indigo-800');
      } else {
        btn.classList.remove('bg-indigo-700', 'hover:bg-indigo-800');
        btn.classList.add('bg-indigo-500', 'hover:bg-indigo-600');
      }
      draw();
    }

    function snapToGridPoint(x, y) {
      if (!snapToGrid) return { x, y };
      return {
        x: Math.round(x / gridSize) * gridSize,
        y: Math.round(y / gridSize) * gridSize
      };
    }

    function drawGrid() {
      if (!snapToGrid) return;
      
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      
      // Vertical lines
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Horizontal lines
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      ctx.setLineDash([]);
    }

    function toggleRobotSimulation() {
      robotSimulation = !robotSimulation;
      const btn = document.getElementById('startRobotBtn');
      const btnText = btn.querySelector('span:last-child');
      
      if (robotSimulation) {
        if (points.length < 4) {
          alert('Need at least 4 points to simulate robot path!');
          robotSimulation = false;
          return;
        }
        btnText.textContent = 'Stop Robot';
        btn.classList.remove('bg-orange-500', 'hover:bg-orange-600');
        btn.classList.add('bg-red-500', 'hover:bg-red-600');
        robotProgress = 0;
        startRobotAnimation();
      } else {
        btnText.textContent = 'Start Robot';
        btn.classList.remove('bg-red-500', 'hover:bg-red-600');
        btn.classList.add('bg-orange-500', 'hover:bg-orange-600');
        stopRobotAnimation();
      }
    }

    function startRobotAnimation() {
      function animate() {
        if (!robotSimulation) return;
        
        robotProgress += robotSpeed;
        
        // Calculate robot position along the path
        if (points.length >= 4) {
          const totalSegments = points.length - 3;
          const currentSegment = Math.floor(robotProgress * totalSegments);
          const localT = (robotProgress * totalSegments) - currentSegment;
          
          if (currentSegment >= totalSegments) {
            // Robot reached the end, restart
            robotProgress = 0;
          } else {
            const segmentIndex = currentSegment + 1; // Offset for Catmull-Rom
            const p0 = points[segmentIndex - 1];
            const p1 = points[segmentIndex];
            const p2 = points[segmentIndex + 1];
            const p3 = points[segmentIndex + 2];
            
            robotPosition.x = catmullRom(p0.x, p1.x, p2.x, p3.x, localT);
            robotPosition.y = catmullRom(p0.y, p1.y, p2.y, p3.y, localT);
          }
        }
        
        draw();
        robotAnimationId = requestAnimationFrame(animate);
      }
      animate();
    }

    function stopRobotAnimation() {
      if (robotAnimationId) {
        cancelAnimationFrame(robotAnimationId);
        robotAnimationId = null;
      }
      draw(); // Redraw without robot
    }

    function drawRobot() {
      if (!robotSimulation || points.length < 4) return;
      
      // Calculate scaling factor for consistent visual size
      const scaleFactor = Math.min(canvas.width / 800, canvas.height / 600);
      const robotRadius = Math.max(6, 12 * scaleFactor);
      const innerDotRadius = Math.max(2, 4 * scaleFactor);
      const borderWidth = Math.max(1, 3 * scaleFactor);
      
      // Draw robot as a blue circle with direction indicator
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath();
      ctx.arc(robotPosition.x, robotPosition.y, robotRadius, 0, 2 * Math.PI);
      ctx.fill();
      
      // Draw robot border
      ctx.strokeStyle = '#1e40af';
      ctx.lineWidth = borderWidth;
      ctx.stroke();
      
      // Draw direction indicator (small white dot)
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(robotPosition.x, robotPosition.y, innerDotRadius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function toggleMoveDotsMode() {
      moveDotsMode = !moveDotsMode;
      const btn = document.getElementById('moveDotsBtn');
      const canvas = document.getElementById('canvas');
      
      if (moveDotsMode) {
        btn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
        btn.classList.add('bg-blue-700', 'hover:bg-blue-800');
        canvas.classList.remove('cursor-crosshair');
        canvas.classList.add('cursor-move');
      } else {
        btn.classList.remove('bg-blue-700', 'hover:bg-blue-800');
        btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
        canvas.classList.remove('cursor-move');
        canvas.classList.add('cursor-crosshair');
        draggingPointIndex = null;
      }
    }

    document.getElementById('bgUpload').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (evt) {
        bgImage.onload = () => {
          resizeCanvas();
          draw();
        };
        bgImage.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    canvas.addEventListener('click', function (e) {
      if (moveDotsMode) return; // Don't add points in move mode
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const snappedPoint = snapToGridPoint(x, y);
      points.push(snappedPoint);
      draw();
    });

    canvas.addEventListener('mousedown', function (e) {
      if (!moveDotsMode) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      
      // Calculate scaling factor for consistent hit detection
      const scaleFactor = Math.min(canvas.width / 800, canvas.height / 600);
      const hitRadius = Math.max(8, 16 * scaleFactor);
      
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        if (Math.hypot(p.x - x, p.y - y) < hitRadius) {
          draggingPointIndex = i;
          break;
        }
      }
    });

    canvas.addEventListener('mousemove', function (e) {
      if (!moveDotsMode || draggingPointIndex === null) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const snappedPoint = snapToGridPoint(x, y);
      points[draggingPointIndex] = snappedPoint;
      draw();
    });

    canvas.addEventListener('mouseup', function () {
      if (!moveDotsMode) return;
      draggingPointIndex = null;
    });

    function clearPoints() {
      points = [];
      shapes = [];
      draw();
    }

    function undobutton() {
      if (points.length > 0) {
        points.pop();
        draw();
      }
    }

    function resizeCanvas() {
      const canvasContainer = canvas.parentElement;
      const containerRect = canvasContainer.getBoundingClientRect();
      const maxWidth = containerRect.width - 32; // Account for padding
      const maxHeight = containerRect.height - 32;
      
      if (bgImage.src) {
        const aspectRatio = bgImage.width / bgImage.height;
        let newWidth = bgImage.width;
        let newHeight = bgImage.height;
        
        if (newWidth > maxWidth) {
          newWidth = maxWidth;
          newHeight = newWidth / aspectRatio;
        }
        
        if (newHeight > maxHeight) {
          newHeight = maxHeight;
          newWidth = newHeight * aspectRatio;
        }
        
        canvas.width = newWidth;
        canvas.height = newHeight;
        scale = newWidth / bgImage.width;
      } else {
        canvas.width = Math.min(800, maxWidth);
        canvas.height = Math.min(600, maxHeight);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (bgImage.src) {
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      }
      
      // Draw grid if snap to grid is enabled
      drawGrid();

      for (const shape of shapes) {
        ctx.fillStyle = shape.color;
        if (shape.type === 'circle') {
          ctx.beginPath();
          ctx.arc(shape.x, shape.y, shape.r, 0, 2 * Math.PI);
          ctx.fill();
        } else if (shape.type === 'rect') {
          ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
        } else if (shape.type === 'triangle') {
          ctx.beginPath();
          ctx.moveTo(shape.x, shape.y);
          ctx.lineTo(shape.x + shape.size, shape.y);
          ctx.lineTo(shape.x + shape.size / 2, shape.y - shape.size);
          ctx.closePath();
          ctx.fill();
        }
      }

      // Calculate scaling factor for consistent visual size
      const scaleFactor = Math.min(canvas.width / 800, canvas.height / 600);
      const dotRadius = Math.max(3, 6 * scaleFactor);
      const pathWidth = Math.max(1, 3 * scaleFactor);
      const robotRadius = Math.max(6, 12 * scaleFactor);

      // Draw control points
      ctx.fillStyle = '#dc2626';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = Math.max(1, 2 * scaleFactor);
      for (let p of points) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, dotRadius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      }

      // Draw spline path
      if (points.length >= 4) {
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = pathWidth;
        ctx.beginPath();
        for (let i = 1; i < points.length - 2; i++) {
          const p0 = points[i - 1];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[i + 2];
          for (let t = 0; t <= 1; t += 0.02) {
            const x = catmullRom(p0.x, p1.x, p2.x, p3.x, t);
            const y = catmullRom(p0.y, p1.y, p2.y, p3.y, t);
            if (t === 0 && i === 1) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      
      // Draw robot if simulation is active
      drawRobot();
    }

    function catmullRom(p0, p1, p2, p3, t) {
      return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);
    }

    function exportPathCSV() {
      if (points.length < 4) {
        alert('Need at least 4 points to export a path!');
        return;
      }

      let csv = 'x,y\n';
      for (let i = 0; i < points.length; i++) {
        csv += `${(points[i].x / scale).toFixed(2)},${(points[i].y / scale).toFixed(2)}\n`;
      }

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'spline_path.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function updateRobotSpeed(value) {
      // Convert slider value (1-20) to robot speed (0.001-0.02)
      robotSpeed = (value / 1000) * 4; // Range from 0.004 to 0.08
    }

    // Handle window resize
    window.addEventListener('resize', function() {
      resizeCanvas();
      draw();
    });

    // Initialize canvas size
    window.addEventListener('load', function() {
      resizeCanvas();
      draw();
    });
  </script>

{% endblock %}

